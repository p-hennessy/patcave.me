<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Database-Linked Dataclasses - The Patcave</title><meta name="description" content="The most common use of a class in Python is acting as a data container. Throughout the development of our backend libraries at Narrative Science, we’ve seen several generations of code that attempts to make modeling this data easy.Finding a simple to use abstraction for these type of classes allows us to focus less on writing mundane classes and more on our business logic.In this post we will outline the evolution of this code and the pros and drawbacks of each approach."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://patcave.me/database-linked-dataclasses/"><link rel="amphtml" href="https://patcave.me/amp/database-linked-dataclasses/"><link rel="alternate" type="application/atom+xml" href="https://patcave.me/feed.xml"><link rel="alternate" type="application/json" href="https://patcave.me/feed.json"><link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700&amp;subset=latin-ext&amp;display=swap" rel="stylesheet"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:'Roboto Condensed',sans-serif;--logo-font:'Roboto Condensed',sans-serif;--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://patcave.me/assets/css/style.css?v=66a9d0fd7079228f8c88f174f9477f17"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://patcave.me/database-linked-dataclasses/"},"headline":"Database-Linked Dataclasses","datePublished":"2021-01-19T14:32","dateModified":"2023-01-11T19:03","image":{"@type":"ImageObject","url":"https://patcave.me/media/posts/14/The-Ultimate-Guide-to-Data-Classes-in-Python-3-2.webp","height":934,"width":1920},"description":"The most common use of a class in Python is acting as a data container. Throughout the development of our backend libraries at Narrative Science, we’ve seen several generations of code that attempts to make modeling this data easy.Finding a simple to use abstraction for these type of classes allows us to focus less on writing mundane classes and more on our business logic.In this post we will outline the evolution of this code and the pros and drawbacks of each approach.","author":{"@type":"Person","name":"Patrick Hennessy","url":"https://patcave.me/authors/patrick-hennessy/"},"publisher":{"@type":"Organization","name":"Patrick Hennessy"}}</script><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Boogaloo&family=Maven+Pro&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://patcave.me/assets/css/prism.css?v=3b135d1db236b56f00e6b8e7a4af7a98"></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://patcave.me/">The Patcave</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://patcave.me/" target="_self">Home</a></li><li><a href="https://patcave.me/about/" target="_self">About</a></li><li class="has-submenu"><span class="is-separator" aria-haspopup="true">Contact</span><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://www.linkedin.com/in/pmhennessy/" target="_blank">LinkedIn</a></li><li><a href="https://github.com/p-hennessy" target="_blank">Github</a></li><li><a href="https://www.youtube.com/channel/UCIw-YA385k1S5IOwYD-iV5Q" target="_blank">YouTube</a></li><li><a href="https://tf2maps.net/members/zeus.28272/" target="_blank">TF2Maps.net</a></li><li><a href="mailto:phennessy517@gmail.com" target="_blank">Email</a></li></ul></li></ul></nav></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://patcave.me/media/posts/14/The-Ultimate-Guide-to-Data-Classes-in-Python-3-2.webp" srcset="https://patcave.me/media/posts/14/responsive/The-Ultimate-Guide-to-Data-Classes-in-Python-3-2-xs.webp 300w, https://patcave.me/media/posts/14/responsive/The-Ultimate-Guide-to-Data-Classes-in-Python-3-2-sm.webp 480w, https://patcave.me/media/posts/14/responsive/The-Ultimate-Guide-to-Data-Classes-in-Python-3-2-md.webp 768w, https://patcave.me/media/posts/14/responsive/The-Ultimate-Guide-to-Data-Classes-in-Python-3-2-lg.webp 1024w, https://patcave.me/media/posts/14/responsive/The-Ultimate-Guide-to-Data-Classes-in-Python-3-2-xl.webp 1360w, https://patcave.me/media/posts/14/responsive/The-Ultimate-Guide-to-Data-Classes-in-Python-3-2-2xl.webp 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="934" width="1920" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2021-01-19T14:32">January 19, 2021</time></div><h1>Database-Linked Dataclasses</h1></div></header></div><div class="wrapper post__entry"><p>The most common use of a class in Python is acting as a data container. Throughout the development of our backend libraries at Narrative Science, we’ve seen several generations of code that attempts to make modeling this data easy.</p><p>Finding a simple to use abstraction for these type of classes allows us to focus less on writing mundane classes and more on our business logic.</p><p>In this post we will outline the evolution of this code and the pros and drawbacks of each approach.</p><hr><h2><strong>V1: Basic classes</strong></h2><p>We have all been here; you write a class, and implement all the <a href="https://levelup.gitconnected.com/python-dunder-methods-ea98ceabad15">dunder</a> methods needed by that class. Simple and straight forward.</p><h5><strong>Example:</strong></h5><pre><code class="language-python">class User():
    def __init__(self, fname, lname, groups):
        if not isinstance(groups, list):
            raise ValueError("groups is not a list!")
        if not isinstance(fname, str):
            raise ValueError("fname is not a str!")
        if not isinstance(lname, str):
            raise ValueError("lname is not a str!")

        self.fname = fname
        self.lname = lname
        self.groups = groups
    
    def __repr__(self):
        return f"User({self.fname},{self.lname})"    </code></pre><h5><strong>Pros:</strong></h5><ul><li>This is very explicit, you can see everything this class does</li><li>Basic, most likely taught in beginner Python courses</li></ul><h5><strong>Cons:</strong></h5><ul><li>Type Checking<br>Notice all the defensive code needed to handle the cases when we receive arguments with incorrect types. Now imagine this example accepted 20 properties. More than likely the author of this code just wouldn’t even bother to write this kind of type checking since it’s tedious and time consuming. However not doing so can create complex error conditions in downstream code.<br><br></li><li>Database<br>Very commonly, these type of objects directly represent data from the database.<br>As it is currently written, you would need another translation layer outside the object to do your queries and create the objects as needed.<br><br></li><li>Testing<strong><br></strong>You will need to write tests to make sure this code correctly rejects invalid inputs.<br><br></li><li>Instantiating<strong><br></strong>In order to create an instance of this object, you need to pass <span data-token-index="1" data-reactroot="">every</span> value into the constructor:<br><pre><code class="language-python">new_user = User("frank", "smith", ["group1", "group2"])
</code></pre><br>It’s worth nothing that it is possible to do some fancy Python magic to create this object out of a dictionary:<pre><code class="language-python">user_data = get_user_data()
new_user = User(**user_data)</code></pre></li></ul><p>But what if I want to dump the properties of this object <em>back</em> to JSON so we could send it over HTTP? You would have to write a method that takes every property and populates a dictionary.</p><hr><h2><strong>V2: Database linked classes</strong></h2><p>The idea here is: what if we created objects that were aware of the database?</p><h5><strong>Example:</strong></h5><pre><code class="language-python">from sqlalchemy import Table, Column, VARCHAR, UUID, JSONB
from ns_database import DatabaseObject

article_table = Table(
    "article",
    Column("id", UUID, primary_key=True),
    Column("name", VARCHAR(45), nullable=False),
    Column("slug", VARCHAR(45), nullable=False),
)

class Article(DatabaseObject):
    table = article_table
    primary_key = app_table.id

new_article = Article.create(id=UUID4(), name="Foo Bar", slug="foo-bar")
new_article.save()<br></code></pre><p>This essentially creates a class that is now able to push and pull its data from a database and functions like a normal object inside of Python.</p><p>The way this DatabaseObject class works is that the properties for the class are determined by the SQL Alchemy table.</p><p>DatabaseObject also implements a handful of convenient methods to help getting data in and out of the database such as: <code>create</code>, <code>get</code>, <code>save</code>, <code>update</code>, and <code>delete</code>. Each will perform the appropriate SQL query.</p><h5><strong>Pros:</strong></h5><ul><li>We have reduced the amount of tedium from boilerplate code.</li><li>Users have a database aware object without needing to write any SQL of their own.</li></ul><h5><strong>Cons:</strong></h5><ul><li>We still have the issue of having to make sure our types are correct when accepting them as parameters.</li><li>We are unable to set default values for properties, so we must always provide all properties, which is tedious. This is because we’re using SQL alchemy as the source of the property names and don’t have a mechanism for passing other values in.</li><li>What if someone inputs a string longer than 45 characters? We need to write code to check for that.</li><li>There is an assumption that we must know the type in Python that corresponds to the SQLAlchemy type.</li><li>Alongside the tests needed for the DatabaseObject class to ensure the database accessor methods work correctly, we will also need to still have tests that ensure that these classes reject invalid inputs and don’t just throw an exception from SQL alchemy.</li></ul><hr><h2><strong>V3: Along came dataclasses</strong></h2><p>Basically, a dataclass is a simple abstraction for classes that store data. It performs automatic type checking, serialization and deserialization, and implements things like <code>__eq__</code>, and gives a standard <code>__repr__</code>. This is basically what we wanted from Generation 1.</p><p>There have been many libraries before this to implement the data-class such as <a href="https://www.attrs.org/en/stable/">attrs</a>, <a href="https://marshmallow.readthedocs.io/en/stable/">marshmallow</a>, and <a href="https://schematics.readthedocs.io/en/latest/">schematics</a>. It is worth noting that Python 3.7 introduced an official the <a href="https://docs.python.org/3/library/dataclasses.html">Dataclass</a> to the core library as well.</p><p>The library we chose to use was <a href="https://pydantic-docs.helpmanual.io/">Pydantic</a> because it worked best with our implementation of <a href="https://fastapi.tiangolo.com/">FastAPI</a>.</p><div class="resource-block resource-block--content"><div class="resource-block__rich-text"><h5><strong>Example:</strong></h5><pre><code class="language-python">from enum import Enum
from typing import Optional
from pydantic import BaseModel, Field

class User(BaseModel):
    name: str = Field(max_length=45)
    department: Department = Field(default=Department.engineering)
    nickname: Optional[str]

class Department(str, Enum):
    engineering = "engineering"
    finance = "finanace"
</code></pre><h5><strong>Pros:</strong></h5><ul><li>Automatic type checking</li><li>Allow us to use other data structures like Enums or other models as types</li><li>Ability to set contraints such as string length</li><li>Ability to set default values</li><li>Greatly reduced boilerplate vs Generation 1</li><li>Easily readable</li><li>Integration with code editors intellisense</li><li>No need to write additional tests</li></ul><p>You can leverage other Python built-ins to do even more powerful things:</p><pre><code class="language-python">class User(BaseModel):
    first_name: str
    last_name: str

    @property
    def email(self):
        return f"{self.firstname[:1]}{self.last_name}@example.com"

    def send_message(self, msg):
        some_email_function(self.email, msg)

...

user = User("John", "Smith")
user.send_message("hey dude!")
</code></pre><p><strong style="color: var(--headings-color); font-family: var(--font-base); font-size: 1.125em; letter-spacing: -0.03rem;">Cons:</strong></p></div></div><ul><li>These models are not database aware like Generation 2.</li></ul><hr><h2><strong>V4: Adding a database to Pydantic</strong></h2><p>Building on our idea from before about turning an ordinary class into a database aware object; we combined the benefits of <a href="https://pydantic-docs.helpmanual.io/usage/validators/">Pydantic's input validation</a> and serialization with the <a href="https://www.sqlalchemy.org/">SQL Alchemy</a> based database class from Generation 2.</p><p>The result is that now we have functional ORM that works with <a href="https://fastapi.tiangolo.com/">FastAPI</a>!</p><h5>Example: </h5><pre><code class="language-python">from enum import Enum
from typing import Optional
from pydantic import BaseModel, Field

from ns_database import database_model, Databases

class UserIn(BaseModel):
    name: str = Field(max_length=45)
    department: Department = Field(default=Department.engineering)
    nickname: Optional[str]

class Department(str, Enum):
    engineering = "engineering"
    finance = "finanace"

@database_model(table_name="users", database_name=Databases.main)
class User(UserIn):
    id: Optional[UUID4] = Field(primary_key=True, fetch_on_create=True)
    created_at: Optional[datetime] = Field(fetch_on_create=True)
    updated_at: Optional[datetime] = Field(fetch_on_create=True
</code></pre><p>We add a class decorator that will use the properties of the model as fields in the database. This means that database models will be 1:1 representations of the database itself.</p><p>Using Pydantic, we are able to add additional keyword arguments to the Field function.</p><h5><strong>Fetch on create / update</strong></h5><p>We want our database to be the ultimate source of authority, so we rely on it to do the computation for certain fields.</p><p>This is done through setting <code>fetch_on_create</code> and <code>fetch_on_update</code> which will defer to the database’s generated value when a record is created or updated respectively.</p><p>All that needs to happen is your database is setup to have column defaults such as static values, subroutines, or sequences.</p><h5><strong>Primary key fields</strong></h5><p>Since all tables will have a primary key, each <code>database_model</code> object <em>must</em> have a primary key.</p><p>Currently we are not able to have compound keys meaning your key must be a single type. This may be a situation where we can create a special type for it to allow it to be more semantic.</p><p>This primary key field is also used by our data accessor method to know how to lookup a record.</p><p> </p><h5><strong>Pros:</strong></h5><ul><li>These database models get all the benefits from Generation 2 and 3!</li></ul><h5><strong>Cons:</strong></h5><ul><li>Lack of foreign key relationships may be misleading to developers. To many developers, this code is their interface to the table schema. Since we use <a href="https://alembic.sqlalchemy.org/en/latest/">Alembic</a> to manage our database schema and updates; there is actually no need to declare fields inside our database_model to be foreign keys. These are only used by SQL Alchemy in order to <em>create</em> your table schema. This does create a situation where our code and schema may not be in-sync. It is also worth noting that those foreign key constraints are still enforced by the database.</li><li>Database managed fields have to be “optional”. One limitation of Pydantic is that we have to make any field that the database will manage (such as the primary_key) as Optional type. The Pydantic validation code runs before we ever make our fetch from the database. This is syntactically a bit confusing.</li></ul><hr><h2><strong>Closing thoughts</strong></h2><p>These new database model classes have greatly improved the readability of our code and reduced the amount of boilerplate we need to write for new objects which ultimately means that we spend more time worrying about our own business logic vs writing all the low level stuff classes usually need.</p><p>As with most projects in software engineering, we kept making marginal improvements to the ideas until we got something awesome! I’m excited to see how this idea continues to grow to further help us achieve these same goals.</p><p>You can find the full code for this here: <a href="https://github.com/NarrativeScience/pynocular">https://github.com/NarrativeScience/pynocular</a></p></div><footer class="wrapper post__footer"><ul class="post__tag"><li><a href="https://patcave.me/tags/computer-science/">Programming Stuff</a></li></ul></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://patcave.me/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://patcave.me/learning-3d-modeling-for-video-games/" class="invert post__nav-link" rel="prev"><span>Previous</span> Learning 3D Modeling for TF2</a></div><div class="post__nav-next"><a href="https://patcave.me/procedural-texture-creation/" class="invert post__nav-link" rel="next"><span>Next</span> Procedural Texture creation </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://patcave.me/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>© Patrick Hennessy 2014 - 2023</p></div></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://patcave.me/assets/js/scripts.min.js?v=48e9576b9741cf2a93ab25c5689c9f5d"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script defer="defer" src="https://patcave.me/assets/js/prism.js?v=321a70a7524222ceadba8f8b6815ce1c"></script></body></html>